You are assembling a comprehensive Jac language reference from extracted signatures and examples.

TARGET: 20-30KB reference document. Include ALL language features - no gaps.

MANDATORY SECTIONS (must include all):

## 1. Syntax & Types
- Primitives: int, float, str, bool, bytes, any
- Collections: list, dict, set, tuple, frozenset
- Type unions: int | None, str | int
- Type annotations: has x: type, -> return_type
- Control flow: if/elif/else, for, while, match/case
- Functions: def with params, returns, defaults
- Lambdas: |params| -> type { body }
- Entry point: with entry { }

## 2. Imports
- Simple: import os;
- Multiple: import sys, json;
- Alias: import datetime as dt;
- From: import from math { sqrt, pi }
- Python interop: import:py from module { func }

## 3. Archetypes
- node: has, can, def, inheritance
- edge: has, typed connections
- walker: has, can with entry/exit, visit, spawn
- obj: value objects, postinit
- enum: enumerations with values

## 4. Access Modifiers
- :pub (public, default)
- :priv (private)
- :prot (protected)

## 5. Graph Operations
- Connect: ++>, <++, <++>, +>:Edge:+>, <+:Edge:+>
- Disconnect: del, --> del
- Traverse: [-->], [<--], [<-->]
- Typed traverse: [-->:EdgeType:]
- Node filter: [-->(`?NodeType)]
- Attribute filter: (?attr == val)
- Combined filters

## 6. Abilities & Events
- can name with Type entry { }
- can name with Type exit { }
- can name with entry { } (generic)
- Execution order (node entry -> walker entry -> walker exit -> node exit)
- Keywords: self, here, visitor, root, `root

## 7. Walker Control
- spawn: walker() spawn node
- visit: visit [-->], visit [-->] else { }
- disengage: stop walker
- report: return values
- skip: skip current node

## 8. AI Integration
- by llm(): basic LLM function
- by llm(method="Reason"): reasoning method
- by llm(model=model_var): model selection
- by llm(tools=[funcs]): tool use
- glob llm = Model(model_name="...")
- Semstrings: """description""" and :sem:
- Structured output with enums/objects
- Image/Video: Image(url=), Video(path=, fps=)

## 9. File I/O & JSON
- file.open(path, mode)
- file.read(), file.write()
- json.dumps(obj), json.loads(str)

## 10. Cloud & API (jac serve)
- jac serve file.jac
- Walker as endpoint
- __specs__: auth, methods, path
- report for API response
- WebSocket support

## 11. Async & Concurrency
- async walker
- async def
- await
- Semaphores

## 12. Persistence
- Automatic persistence in jac-cloud
- glob for global nodes
- Root connectivity for persistence

## 13. Testing
- test { } blocks
- assert statements
- check statements

## 14. Data Spatial Operations
- References and paths
- Edge operations
- Node filtering

## 15. Standard Library
- print, input
- range, len, enumerate
- str methods, list methods
- Math operations

## 16. Patterns (2-3 complete examples)
- Graph traversal with collection
- Search with early exit
- AI-powered processing
- API endpoint walker

FORMAT RULES:
1. Use ### for subsections within ## sections
2. Include signature pattern before each example: `syntax pattern`
3. Use tables for operators and keywords
4. Examples should be 5-25 lines, complete and runnable
5. Include comments in examples only when clarifying non-obvious behavior
6. Every operator mentioned must have an example
7. Quick reference tables at the end

CRITICAL - MUST PRESERVE EXACTLY:
- Edge operators: ++>, <++, <++>, -->, <-->, +>, <+, +>:Edge:+>, <+:Edge:+>
- Keywords: spawn, visit, disengage, report, skip, here, self, visitor, root, `root
- Abilities: can, with entry, with exit
- LLM: by llm(), glob llm, Model, Image, Video, :sem:
- Types: has, def, ->, |
- Specs: __specs__, static has
- File: file.open, json.dumps, json.loads
- Test: test { }, assert, check

---

EXTRACTED CONTENT:
{content}

---

Generate the complete reference. Cover ALL topics listed above. Target 20-30KB.
Do not skip any section. Every section header listed above must appear in output.
