# Jac Language Reference

## Syntax & Types

### Primitives & Collections
```jac
has name: str;
has age: int = 0;
has score: float = 0.0;
has active: bool = True;
has items: list[str] = [];
has data: dict[str, int] = {};
has coords: tuple[int, int];
has maybe_val: int | None = None;
```

### Control Flow
```jac
# Conditionals
if age <= 12 { print("Child"); }
elif age <= 19 { print("Teen"); }
else { print("Adult"); }

# Loops
for item in items { print(item); }
for i in range(10) { print(i); }
while count > 0 { count -= 1; }

# Match
match value {
    case 1 => print("one");
    case 2 => print("two");
    case _ => print("other");
}
```

### Functions & Lambdas
```jac
def compute(x: int, y: int) -> int {
    return x + y;
}

def greet { print("Hello!"); }  # No params/return

# Lambda
transform = |x: int| -> int { x * 2 };
```

### Entry Point
```jac
with entry {
    # Program starts here
    print("Hello, Jac!");
}
```

## Archetypes

### Node - Graph Vertices
`node Name { has attr: type; can ability with Walker entry { } }`

```jac
node Person {
    has name: str;
    has age: int;
    
    can greet with Visitor entry {
        print(f"Hello from {self.name}");
    }
}
```

### Edge - Typed Relationships
`edge Name { has attr: type = default; }`

```jac
edge Knows {
    has since: int = 2024;
    has strength: int = 5;
}

edge WorksAt {
    has position: str;
    has salary: float;
}
```

### Walker - Mobile Computation
`walker Name { has state: type; can ability with Node entry { visit [-->]; } }`

```jac
walker Collector {
    has data: list = [];

    can start with `root entry {
        visit [-->];
    }

    can collect with Person entry {
        self.data.append({"name": here.name});
        visit [-->];
    }
}
```

### Obj - Value Objects
```jac
obj Rectangle {
    has width: float;
    has height: float;
    has area: float by postinit;

    def postinit() -> None {
        self.area = self.width * self.height;
    }

    def scale(factor: float) -> None {
        self.width *= factor;
        self.height *= factor;
    }
}
```

### Enum - Enumerations
```jac
enum Role { ADMIN, USER, VIEWER }
enum Sentiment { POSITIVE, NEGATIVE, NEUTRAL }
```

### Access Modifiers
```jac
obj Example {
    has :priv secret: str;           # Private
    has :pub public_val: int;        # Public (default)
    def :priv helper() -> str { }    # Private method
}
```

## Graph Operations

### Connect Operators
| Operator | Description |
|----------|-------------|
| `++>` | Create forward edge (returns list of target nodes) |
| `<++` | Create backward edge |
| `<++>` | Create bidirectional edges |
| `+>:Edge:+>` | Forward edge with type |
| `<+:Edge:+>` | Bidirectional typed edge |

```jac
with entry {
    alice = Person(name="Alice", age=25);
    bob = Person(name="Bob", age=30);
    
    root ++> alice;                           # Connect to root
    alice ++> bob;                            # Forward edge
    alice +>:Knows(since=2020):+> bob;       # Typed edge
    alice <+:Knows(since=2020):+> bob;       # Bidirectional typed
}
```

### Traverse Operators
| Syntax | Description |
|--------|-------------|
| `[-->]` | All outgoing edges/nodes |
| `[<--]` | All incoming edges/nodes |
| `[<-->]` | Both directions |
| `[-->:EdgeType:]` | Filter by edge type |
| `[-->(\`?NodeType)]` | Filter by node type |

### Filter Syntax
```jac
# Get connected nodes
people = [root --> Person];

# Filter by type
adults = [root --> (`?Person)];

# Filter by attribute
seniors = [root --> (`?Person)](?age >= 65);

# Filter by edge type
friends = [alice -->:Knows:];

# Combined
close_friends = [alice -->:Knows:(`?Person)](?strength > 7);
```

### Visit & Traversal
```jac
walker Traverser {
    can traverse with entry {
        visit [-->];              # Visit forward connections
        visit [<--];              # Visit backward connections
        visit [<-->];             # Visit both directions
        
        visit [-->] else {        # Handle end of path
            print("End of path");
            disengage;
        }
    }
}
```

### Spawn
```jac
with entry {
    root ++> Person(name="Alice");
    
    # Spawn walker at node
    w = Collector() spawn root;
    
    # Access walker state after traversal
    print(w.data);
}
```

## Abilities & Events

### Keywords
| Keyword | Description |
|---------|-------------|
| `self` | Current archetype instance |
| `here` | Current node being visited |
| `visitor` | Walker visiting the node |
| `root` | Graph root node |
| `` `root `` | Root node type for matching |

### Entry/Exit Abilities
```jac
node Room {
    has name: str;
    
    can welcome with Visitor entry {
        print(f"Welcome to {self.name}");
    }
    
    can farewell with Visitor exit {
        print(f"Goodbye from {self.name}");
    }
}

walker Visitor {
    can start with `root entry {
        visit [-->];
    }
    
    can visit_room with Room entry {
        print(f"Visiting {here.name}");
        visit [-->];
    }
    
    can leave_room with Room exit {
        print(f"Leaving {here.name}");
    }
    
    can finish with exit {
        print("Walker finished");
    }
}
```

### Execution Order
1. Node's generic `with entry` abilities
2. Node's `with WalkerType entry` abilities  
3. Walker's `with NodeType entry` abilities
4. Walker's `with NodeType exit` abilities
5. Node's `with WalkerType exit` abilities
6. Node's generic `with exit` abilities

### Control Flow
- `visit [-->]` - Queue nodes for traversal
- `disengage` - Stop walker immediately
- `report value` - Return value from walker

```jac
walker SearchWalker {
    has target: str;
    has found: bool = False;

    can search with Person entry {
        if here.name == self.target {
            self.found = True;
            report here;    # Return the found node
            disengage;      # Stop traversing
        }
        visit [-->];
    }
}
```

## AI Integration

### Basic LLM Functions
```jac
import from byllm.lib { Model }
glob llm = Model(model_name="gpt-4o-mini");

"""Summarize the given text into 2-3 sentences."""
def summarize(text: str) -> str by llm();

with entry {
    summary = summarize("Long article text here...");
    print(summary);
}
```

### Structured Output
```jac
import from byllm.lib { Model }
glob llm = Model(model_name="gpt-4o-mini");

enum Sentiment { POSITIVE, NEGATIVE, NEUTRAL }

"""Analyze the sentiment of the text."""
def get_sentiment(text: str) -> Sentiment by llm();

with entry {
    result = get_sentiment("I love this product!");
    print(result);  # Sentiment.POSITIVE
}
```

### Image/Video Analysis
```jac
import from byllm.lib { Model, Image, Video }
glob llm = Model(model_name="gpt-4o");

"""Describe what you see in this image."""
def describe_image(img: Image) -> str by llm();

"""Summarize the key events in this video."""
def analyze_video(v: Video) -> str by llm();

with entry {
    img = Image(url="https://example.com/photo.jpg");
    description = describe_image(img);
    
    vid = Video(path="video.mp4", fps=1);
    summary = analyze_video(vid);
}
```

### Semantic Strings (Semstrings)
```jac
enum AgentType {
    RESEARCHER = "Handles web searches and information gathering" :sem:,
    CODER = "Writes and reviews code" :sem:,
    WRITER = "Creates and edits text content" :sem:
}
```

## Cloud & API

### Serve Walkers as Endpoints
```bash
jac serve main.jac
```

### Walker Specs
```jac
walker get_counter {
    obj __specs__ {
        static has auth: bool = False;      # Public endpoint
        static has methods: list = ["GET"]; # HTTP methods
    }

    can get_counter_endpoint with `root entry {
        counter_nodes = [root --> Counter];
        if not counter_nodes {
            counter = Counter();
            root ++> counter;
        } else {
            counter = counter_nodes[0];
        }
        report {"value": counter.get_value()};
    }
}
```

### Report for API Response
```jac
walker create_post {
    has content: str;
    has author: str;

    can create with `root entry {
        new_post = Post(content=self.content, author=self.author);
        here ++> new_post;
        report {"id": new_post.id, "status": "posted"};
    }
}
```

## Persistence

### Global Variables
```jac
glob END = EndNode();  # Persistent global node

with entry {
    node_a ++> END;  # Connect to global
}
```

### Graph Persistence
Nodes and edges connected to `root` persist automatically in jac-cloud/jac-scale.

## Patterns

### Complete Graph Traversal Example
```jac
node Person {
    has name: str;
    has age: int;
}

edge Knows {
    has since: int = 2024;
}

walker Collector {
    has data: list = [];

    can start with `root entry {
        visit [-->];
    }

    can collect with Person entry {
        self.data.append({"name": here.name, "age": here.age});
        visit [-->];
    }
}

with entry {
    alice = Person(name="Alice", age=30);
    bob = Person(name="Bob", age=25);
    
    root ++> alice;
    alice +>:Knows(since=2020):+> bob;

    c = Collector() spawn root;
    print(c.data);  # [{"name": "Alice", "age": 30}, {"name": "Bob", "age": 25}]
}
```

### Search with Early Exit
```jac
walker FindPerson {
    has target_name: str;
    has result: Person | None = None;

    can start with `root entry {
        visit [-->];
    }

    can search with Person entry {
        if here.name == self.target_name {
            self.result = here;
            report here;
            disengage;
        }
        visit [-->];
    }
}

with entry {
    root ++> Person(name="Alice", age=30);
    root ++> Person(name="Bob", age=25);
    
    finder = FindPerson(target_name="Bob") spawn root;
    print(finder.result.name);  # Bob
}
```

### AI-Powered Node Processing
```jac
import from byllm.lib { Model }
glob llm = Model(model_name="gpt-4o-mini");

node Document {
    has content: str;
    has summary: str = "";
}

"""Summarize the document in one sentence."""
def summarize(text: str) -> str by llm();

walker Summarizer {
    can process with Document entry {
        here.summary = summarize(here.content);
        print(f"Summarized: {here.summary}");
        visit [-->];
    }
}

with entry {
    doc = Document(content="Long document text...");
    root ++> doc;
    Summarizer() spawn root;
}
```

## Quick Reference

### Operators
| Operator | Purpose |
|----------|---------|
| `++>` | Connect forward |
| `<++` | Connect backward |
| `<++>` | Connect bidirectional |
| `+>:E:+>` | Typed forward edge |
| `[-->]` | Traverse forward |
| `[<--]` | Traverse backward |
| `spawn` | Start walker at node |
| `visit` | Queue nodes to visit |
| `disengage` | Stop walker |
| `report` | Return value |

### Keywords
| Keyword | Context |
|---------|---------|
| `self` | Current instance |
| `here` | Current node (in walker) |
| `visitor` | Visiting walker (in node) |
| `root` | Graph root |
| `` `root `` | Root type matcher |
| `entry` | Enter event |
| `exit` | Leave event |