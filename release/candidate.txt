Jac Language Reference

SYNTAX AND TYPES

Jac provides primitive types int float str bool bytes any for basic data representation. Collections include list[T] for ordered sequences, dict[K,V] for key-value mappings, set[T] for unique elements, tuple[T,...] for fixed sequences, and frozenset[T] for immutable sets. Type unions use the pipe operator as in int | None for optional values. Type annotations appear with has x: type for member variables and -> return_type for function returns. Control flow uses if/elif/else for conditionals as in if age <= 12 { print("Child"); } elif age <= 19 { print("Teenager"); } else { print("Adult"); }. Loops include for item in collection { } and while condition { }. Pattern matching uses match value { case pattern => action; }. Functions are defined with def name(param: type) -> return_type { body } supporting default parameters. Lambdas use the syntax |params| -> type { body } for inline functions. The entry point for any Jac program is with entry { } which executes when the module loads, as in with entry { width: float = 5.0; height: float = 3.0; area = width * height; print(f"The area is {area}"); }.

IMPORTS

Simple imports use import os; for single modules. Multiple imports combine as import sys, json; on one line. Aliased imports use import datetime as dt; for convenience. Selective imports from modules use import from math { sqrt, pi } to bring specific items into scope. Python interoperability is achieved with import:py from module { func } to access Python libraries directly. Module imports can also use import from byllm.lib { Model, Image } for specialized libraries.

ARCHETYPES

Nodes represent graph vertices with state and behavior defined using has for properties and can/def for methods. A basic node looks like node Person { has name: str; has age: int; def greet -> str; } where has declares member variables and def declares methods. Nodes support inheritance as in node FriendlyPerson(Person) { has name: str; can greet with Visitor entry; } where the child extends the parent. Edges represent typed connections between nodes with their own properties as in edge Knows { has since: int = 2024; } or edge WorksAt { has position: str; has salary: float; has start_date: str; def validate_employment -> bool; }. Walkers are mobile computational units that traverse graphs, defined as walker Visitor { has name: str; can start with `root entry; can meet_person with Person entry; can finish with exit; } where abilities trigger on specific node types. The obj archetype creates value objects with obj Rectangle { has width: float; has height: float; has area: float by postinit; def postinit() -> None { self.area = self.width * self.height; } } where postinit computes derived values after initialization. Enumerations use enum Sentiment { POSITIVE, NEGATIVE, NEUTRAL } for fixed value sets.

ACCESS MODIFIERS

Access control uses :pub for public access which is the default, :priv for private access restricted to the defining archetype, and :prot for protected access available to subclasses. These apply to both properties and methods as in has :priv private_property: str; for private data and def :priv private_method() -> str { return "private"; } for private methods. A complete example shows obj PrivateExample { has :priv private_property: str; has :priv another_private_property: int = 42; def :priv private_method() -> str { return "This is a private method"; } def :pub public_method() -> str { return self.private_method(); } } where public methods can access private members internally.

GRAPH OPERATIONS

Connection operators create edges between nodes. The ++> operator creates a forward edge and returns the target as a list, used as root ++> Person(name="Alice"); to connect root to a new Person. The <++ operator creates a backward edge as alice <++ bob; making Bob point to Alice. The <++> operator creates bidirectional edges as alice <++> bob; for two-way relationships. The +> and <+ operators connect without returning results. Typed edges use +>:EdgeType:+> syntax as in alice[0] +>:Knows(years=5):+> bob[0]; to create edges with properties. Disconnection uses del to remove edges. Traversal operators query graph structure with [-->] for forward edges, [<--] for backward edges, and [<-->] for both directions. Typed traversal filters by edge type as [-->:Knows:] to follow only Knows edges. Node type filtering uses [-->(`?Person)] to visit only Person nodes. Attribute filtering applies conditions as (?attr == val) or [root --> Book](?isbn == isbn) to select nodes matching criteria. Combined filtering chains these as [-->:Knows:(`?Person)] for typed edges to specific node types.

ABILITIES AND EVENTS

Abilities define behavior triggered by walker visits using can name with Type entry { } for entry actions and can name with Type exit { } for exit actions. Generic abilities use can name with entry { } to trigger on any node type. The execution order when a walker visits a node is node entry abilities first, then walker entry abilities, then walker exit abilities, finally node exit abilities. Within abilities, self refers to the current archetype instance, here refers to the current node being visited, visitor refers to the visiting walker when in a node ability, root refers to the walker's spawn root, and `root specifically matches the graph root node in ability signatures. A complete sequence example shows node Node { has val: str; can entry1 with entry { print(f"{self.val}-2"); } can entry2 with Walker entry { print(f"{self.val}-3"); } can exit1 with Walker exit { print(f"{self.val}-4"); } can exit2 with exit { print(f"{self.val}-5"); } } with corresponding walker abilities demonstrating the full lifecycle.

WALKER CONTROL

Walkers are spawned onto nodes with walker_instance = Greeter() spawn root; which creates the walker and begins traversal at the specified node. The visit statement directs walker movement as visit [-->]; to follow forward edges, visit [<--]; for backward edges, or visit [<-->]; for both. Visit with else handles dead ends as visit [-->] else { print("End of path"); disengage; }. The disengage keyword immediately stops walker traversal, useful when a target is found as in if here.name == self.target { self.found = True; disengage; }. The report keyword returns values from walkers as report {"id": new_post.id, "status": "posted"}; for API responses or report here; to return the current node. The skip keyword skips processing of the current node. A complete traversal example shows walker Collector { has data: list = []; can start with `root entry { visit [-->]; } can collect with Person entry { self.data.append({"name": here.name}); visit [-->]; } } which collects names from all Person nodes reachable from root.

AI INTEGRATION

The by llm() suffix delegates function implementation to a language model. Basic usage defines a function signature with docstring as """Summarize the given text into 2-3 sentences.""" def summarize(text: str) -> str by llm(); where the docstring becomes the prompt. Configuration requires import from byllm.lib { Model } and glob llm = Model(model_name="gpt-4o-mini"); to set the default model. Chain-of-thought reasoning uses by llm(method="Reason") for step-by-step thinking. ReAct reasoning with actions uses by llm(method="ReAct") for tool-augmented responses. Model selection per call uses by llm(model=var) to override the default. Tool use passes functions as by llm(tools=[funcs]) for the model to invoke. Structured output works with enums as enum Sentiment { POSITIVE, NEGATIVE, NEUTRAL } with """Analyze the sentiment.""" def get_sentiment(text: str) -> Sentiment by llm(); returning typed values. Semstrings provide semantic context using triple quotes on archetypes as """A person with social preferences""" and :sem: annotations for fields. Multimodal input uses Image(url="https://example.com/photo.jpg") or Image(url="/path/to/image.png") for images and Video(path="video.mp4", fps=1) for video analysis with configurable frame extraction rate.

FILE IO AND JSON

File operations use file.open(path, mode) to open files with modes like "r" for read and "w" for write. Reading uses file.read() to get contents as string. Writing uses file.write(content) to output data. Closing uses file.close() to release resources. JSON serialization uses json.dumps(obj) to convert objects to JSON strings and json.loads(str) to parse JSON strings back to objects. These integrate with walker report statements for API responses.

CLOUD AND API

Jac Cloud serves applications with jac serve file.jac which automatically exposes walkers as HTTP endpoints. Each walker becomes an endpoint at /walker/walker_name. The __specs__ object configures endpoint behavior with static has properties. Authentication control uses obj __specs__ { static has auth: bool = False; } to make endpoints public or static has auth: bool = True; for protected endpoints. HTTP methods are set with static has methods: list = ["GET"]; or ["POST"] or ["websocket"]. Custom paths use static has path: str = "/custom/path";. Query parameters are specified with static has as_query: list = ["param_name"];. Private walkers not exposed as endpoints use static has private: bool = True;. Walker has variables become request parameters and report statements become response bodies. A complete endpoint example shows walker get_counter { obj __specs__ { static has auth: bool = False; } can get_counter_endpoint with `root entry { counter_nodes = [root --> Counter]; if not counter_nodes { counter = Counter(); root ++> counter; } else { counter = counter_nodes[0]; } report {"value": counter.get_value()}; } } which creates or retrieves a counter and returns its value. File uploads use the UploadFile type for multipart form data.

WEBSOCKET

WebSocket endpoints are configured with static has methods: list = ["websocket"]; in the walker __specs__. Socket communication methods include socket.notify_users(user_ids, message) to send to specific users, socket.notify_channels(channel_names, message) to broadcast to channels, and socket.notify_clients(client_ids, message) for direct client messaging. WebSocket walkers maintain persistent connections for real-time bidirectional communication.

WEBHOOKS

Webhook endpoints are configured in __specs__ with webhook settings specifying the authentication type and parameter name. Configuration uses static has webhook: dict = {"type": "header", "name": "X-Webhook-Secret"}; for header-based auth, {"type": "query", "name": "token"} for query parameter auth, or {"type": "body", "name": "secret"} for body-based auth. Webhook endpoints are accessed at /webhook/walker/walker_name with the specified authentication mechanism.

SCHEDULER

Scheduled execution is configured in __specs__ with schedule settings. Cron scheduling uses static has schedule: dict = {"trigger": "cron", "hour": "9", "minute": "0"}; for daily execution at specific times. Interval scheduling uses {"trigger": "interval", "seconds": 30} for periodic execution. One-time scheduling uses {"trigger": "date", "run_date": "2024-12-31T23:59:59"} for specific datetime execution. Scheduled walkers should include static has private: bool = True; since they run server-side without HTTP exposure.

ASYNC

Asynchronous walkers are declared with async walker AsyncFetcher { } enabling non-blocking operations. Async methods use async def method_name() for coroutine definitions. The await keyword pauses execution until async operations complete as data = await here.fetch_async();. Task status is checked via task.__jac__.status for completion state, task.__jac__.reports for collected results, and task.__jac__.error for any exceptions. Task creation uses create_task() to queue async operations for concurrent execution.

PERMISSIONS

Permission levels control access to nodes with NoPerm for no access, ReadPerm for read-only access, ConnectPerm for connection ability, and WritePerm for full modification rights. Granting permissions uses _.allow_root(node, target_root, level) to give another root access to a node or grant(node, level) for simplified granting. Revoking permissions uses _.disallow_root(node, target) to remove access or revoke(node) for simplified revocation. Custom access control implements __jac_access__ methods on nodes for fine-grained permission logic.

PERSISTENCE

Nodes automatically persist when connected to the root graph, requiring no explicit save calls for basic persistence. Manual persistence uses save(node) to explicitly save a node, commit() to flush all pending changes, or commit(Type) to commit all instances of a specific type. Global nodes declared with glob persist across sessions as glob END = EndNode(); creating a singleton accessible throughout the application. Node references use &"n::id" syntax to retrieve nodes by their persistent identifier, enabling cross-session node access.

TESTING

Test blocks define unit tests with test { } containing assertions. The assert keyword fails the test immediately if the condition is false, used as assert result == expected;. The check keyword performs soft assertions that record failures but continue execution, useful for collecting multiple validation results. Tests run with the jac test command which discovers and executes all test blocks in the specified files.

STANDARD LIBRARY

Built-in functions include print(value) for output, input(prompt) for user input, range(start, stop, step) for numeric sequences, len(collection) for size, enumerate(iterable) for index-value pairs, type(obj) for type inspection. Type conversion uses str(value), int(value), float(value), list(iterable), dict(pairs). String methods include upper() lower() strip() for case and whitespace, split(delimiter) join(iterable) for splitting and joining, replace(old, new) for substitution. List methods include append(item) extend(iterable) insert(index, item) for adding, remove(item) pop(index) for removing, sort() reverse() for ordering. Dict methods include keys() values() items() for iteration, get(key, default) for safe access, update(other) for merging, pop(key) for removal with return.

DEPLOYMENT

Docker deployment uses a Dockerfile with FROM python:3.11-slim as base, RUN pip install jaclang jac-cloud for dependencies, COPY . /app for application code, and CMD ["jac", "serve", "main.jac"] for startup. Environment variables configure DATABASE_URL for persistence backend, JAC_SECRET_KEY for authentication tokens, and OPENAI_API_KEY for AI integration. Kubernetes deployment creates a Deployment resource with container spec referencing the Docker image, a Service for internal networking, and an Ingress for external access with TLS termination.

PATTERNS

Graph traversal with collection demonstrates walker-based data gathering as walker Collector { has data: list = []; can start with `root entry { visit [-->]; } can collect with Person entry { self.data.append({"name": here.name, "age": here.age}); visit [-->]; } } spawned with c = Collector() spawn root; then accessing c.data for results. AI-powered processing shows LLM integration as import from byllm.lib { Model } glob llm = Model(model_name="gpt-4o-mini"); enum Sentiment { POSITIVE, NEGATIVE, NEUTRAL } """Analyze sentiment of the review.""" def analyze(text: str) -> Sentiment by llm(); with entry { result = analyze("Great product!"); print(result); }. API endpoint walker demonstrates REST service as walker create_post { has content: str; has author: str; obj __specs__ { static has auth: bool = False; static has methods: list = ["POST"]; } can create with `root entry { new_post = Post(content=self.content, author=self.author); here ++> new_post; report {"id": str(new_post), "status": "created"}; } }. Search with early termination shows efficient graph queries as walker FindFirstMatch { has target: str; has result: any = None; can search with Person entry { if here.name == self.target { self.result = here; report here; disengage; } visit [-->]; } } which stops immediately upon finding the target node rather than traversing the entire graph.